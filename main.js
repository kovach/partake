import {
  parseQuery,
  unrename,
  joins,
  joinTuples,
  dbOfList,
  selectTuples,
  selectTuplesWithSource,
  dbAddTuple,
  af,
  str,
  clone,
  emptyDb,
  dbContains,
  evalQuery,
  isLiteral,
  valEqual,
} from "./join.js";

import * as d from "./dom.js";

import grammar from "./grammar.js";

class MonoidMap {
  constructor(zero, plus) {
    this.map = new Map();
    this.zero = zero;
    this.plus = plus;
  }
  get(key) {
    let v = this.map.get(key);
    if (v === undefined) {
      v = this.zero();
      this.map.set(key, v);
    }
    return v;
  }
  add(key, value) {
    let v = this.get(key);
    this.plus(v, value);
    return v;
  }
}

class ArrayMap extends MonoidMap {
  constructor() {
    super(
      () => [],
      (a, b) => a.push(b)
    );
  }
}

let debugSteps = false;
let debugResult = false;
let debugIterTag = true;

// Create a Parser object from our grammar.

function parse(str) {
  let parser = new nearley.Parser(grammar);
  //let parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
  parser.feed(str);
  let result = parser.results;
  if (result.length > 0) return result[0];
  return null;
}
function parseNonterminal(nt, text) {
  let g = nearley.Grammar.fromCompiled(grammar);
  g.start = nt;
  let parser = new nearley.Parser(g);
  parser.feed(text);
  let result = parser.results;
  if (result.length > 0) return result[0];
  return null;
}

//console.log(JSON.stringify(parse("foo X Y, baz z, bar")));
//console.log(JSON.stringify(parse("bar, after (foo X, bar Y)")));
//console.log(JSON.stringify(parse("bar, before (x), after (foo X, bar Y)")));

// Stack Object related constructors
function mkNewTuples(value) {
  return {
    tag: "newTuples",
    value,
  };
}
function mkLine(value) {
  return {
    tag: "line",
    value,
  };
}
// Operation related constructors
function mkContext(binding) {
  return { binding, del: [], add: [] };
}
function bindingDiff(b1, b2) {
  let result = {};
  for (let key in b2) {
    if (!(key in b1)) {
      result[key] = b2[key];
    }
  }
  return result;
}
function matchRule(rule, tuples) {
  let { name, guard, body } = rule;
  let db = dbOfList(tuples);
  let bindings = af(selectTuples(db, guard));
  return { name, contexts: bindings.map(mkContext), lines: body };
}
function matchRules(rules, tuples) {
  let result = [];
  for (let rule of rules) {
    let { name, contexts, lines } = matchRule(rule, tuples);
    if (contexts.length > 0) {
      lines.reverse().forEach((operations) => {
        result.push(
          mkLine({ name, contexts, operations, ruleText: rule.ruleText })
        );
      });
    }
  }
  return result;
}

function makeTuple(binding, pattern) {
  let [tag, atoms] = pattern;
  return [tag, unrename(binding, atoms)];
}

function evalLiteral(term, binding) {
  let val = isLiteral(term);
  if (val !== null) return val;
  if (term in binding) return binding[term];
  throw "var missing from binding";
}

function stepOperation(db, contexts, operation) {
  // TODO: switch to joinBindings
  function* iter(cs, fn) {
    for (let c of cs) {
      for (let [t, vals] of selectTuplesWithSource(db, operation.pattern)) {
        let v = fn(c, vals, t);
        if (v) yield v;
      }
    }
  }
  function doRel(c, vals) {
    let binding = joinTuples(c.binding, vals);
    if (binding) {
      return { binding, del: c.del, add: c.add };
    }
  }
  function doBeforeRel(c, vals, t) {
    let binding = joinTuples(c.binding, vals);
    if (binding) {
      return { binding, del: c.del.concat([t]), add: c.add };
    }
  }
  let result = [];
  switch (operation.tag) {
    case "rel":
      for (let c of iter(contexts, doRel)) result.push(c);
      break;
    case "before":
      for (let c of iter(contexts, doBeforeRel)) result.push(c);
      break;
    case "after":
      for (let { binding, del, add } of contexts) {
        result.push({
          binding,
          del,
          add: add.concat([makeTuple(binding, operation.pattern)]),
        });
      }
      break;
    // generated by parser for `choose` with `_choices` as the name
    case "subQuery":
    case "countQuery":
      for (let c of contexts) {
        let { name, body } = operation;
        let choices = af(
          evalQuery(db, body, [{ bindings: c.binding, used: [] }])
        );
        if (operation.tag === "subQuery") c.binding[name] = choices;
        else if (operation.tag === "countQuery")
          c.binding[name] = choices.length;
        else throw "unreachable";
        result.push(c);
      }
      break;
    case "takeChoice":
      throw "unreachable: `takeChoice` is handled by fixStack";
    case "applyChoices":
      for (let { binding, del, add } of contexts) {
        for (let b of binding._choices) {
          b = structuredClone(b);
          result.push({ binding: b, del, add });
        }
      }
      break;
    case "binOp":
      let fn;
      if (operation.operator === "<") fn = (a, b) => a < b;
      else if (operation.operator === "=") fn = (a, b) => a === b;
      else throw "unimplemented operator";
      for (let context of contexts) {
        let l = evalLiteral(operation.l, context.binding);
        let r = evalLiteral(operation.r, context.binding);
        if (fn(l, r)) result.push(context);
      }

      break;
    default:
      throw ["undefined tag stepOperation", operation];
  }
  if (debugSteps) console.log("    result: ", JSON.stringify(result));
  return result;
}

function unionContexts(contexts) {
  let del = [];
  let add = [];
  for (let { del: d, add: a } of contexts) {
    for (let t of d) del.push(t);
    for (let t of a) add.push(t);
  }
  return { del, add };
}

let stepLimit = 200;
function fixStack(db, rules, trace, stack) {
  let count = 0;
  loop: while (stack.length > 0 && count++ < stepLimit) {
    let obj = stack.pop();
    if (debugIterTag) console.log(obj.tag);
    switch (obj.tag) {
      case "newTuples":
        let matches = matchRules(rules, obj.value);
        stack = stack.concat(matches);
        if (debugSteps) console.log("    matches: ", str(matches));
        break;
      case "line":
        let { name, ruleText, contexts, operations } = obj.value;
        if (operations.length > 0) {
          let op = operations[0];
          operations = operations.slice(1);
          if (op.tag === "takeChoice") {
            // todo: other quantifiers
            contexts = contexts.filter((c) => c.binding._choices.length > 0);
            trace.push({
              tag: "choice",
              type: "one",
              db,
              rules,
              trace,
              stack,

              contexts,
              operations,
              name,
              ruleText,
            });
            return;
          } else {
            stack.push(
              mkLine({
                contexts: stepOperation(db, contexts, op),
                operations,
                ruleText,
                name,
              })
            );
          }
        } else {
          if (debugResult)
            console.log("    result: ", JSON.stringify(contexts));
          let { del, add } = unionContexts(contexts);
          for (let [tag, tuple] of del) dbAddTuple(db, tag, tuple, -1);
          for (let [tag, tuple] of add) dbAddTuple(db, tag, tuple, +1);
          if (add.length > 0) stack.push(mkNewTuples(add));
          //renderDb(db);
          trace.push({ tag: "record", db: clone(db), name, ruleText });
        }
        break;
      default:
        throw ["undefined tag fixStack", obj];
    }
  }
}

let app;
let valRefs;
let tupleRefs;
function ppTuple(tag, tuple) {
  tuple = tuple.map((term) => {
    if (Array.isArray(term) && term.length === 2 && term[0] === "sym")
      return `'${term[1]}`;
    else return term;
  });
  let tupleText = tuple.join(" ");
  return `(${tag}${tupleText.length > 0 ? " " + tupleText : ""})`;
}
function renderDb(db, previous) {
  if (app) d.remove(app);
  valRefs = new ArrayMap();
  tupleRefs = new ArrayMap();
  app = d.createChildId("div", "left");
  //app.style.fontSize = "16pt";
  for (let [tag, rel] of db.entries()) {
    for (let [value, _] of rel.values()) {
      //console.log(`(${tag} ${value.join(" ")})`);
      let e = d.createChild("div", app);
      e.innerHTML = ppTuple(tag, value);
      if (previous) {
        if (!dbContains(previous, tag, value)) {
          e.style["background-color"] = "#a000b5";
          e.style["color"] = "#ffffff";
          //e.style["font-weight"] = "bold";
        }
      }
      for (let v of value) valRefs.add(v, e);
      tupleRefs.add(str([tag, value]), e);
    }
  }
}

let globalChoiceState = {};
let elementDbMap = new Map();
function renderTraceEntry(entry) {
  switch (entry.tag) {
    case "choice":
      globalChoiceState.states = new Map();
      globalChoiceState.entry = entry;
      globalChoiceState.elements = [];
      for (let context of entry.contexts) {
        let contextChoiceState = { type: "one", chosen: new Set() };
        globalChoiceState.states.set(context, contextChoiceState);
        renderContextChoices(context);
      }
      break;
    case "record":
      let { name, ruleText, db } = entry;
      let e = d.createChildId("div", "right");
      e.innerHTML = name;
      elementDbMap.set(e, db);
      e.onmouseenter = () => {
        let prevDb = e.previousSibling
          ? elementDbMap.get(e.previousSibling)
          : emptyDb();
        renderDb(db, prevDb, e);
        d.getId("rule").innerHTML = ruleText;
      };
      break;
  }
}
function ppBinding(binding) {}
function renderContextChoices(c) {
  let state = globalChoiceState.states.get(c).chosen;
  let e = d.createChildId("div", "right");
  e.innerHTML = "choose [exactly 1]:";
  c.binding._choices.forEach((o) => {
    renderChoice(state, e, o, c.binding);
  });
  globalChoiceState.elements.push(e);
}
function renderChoice(chosen, parent, { bindings: binding, used }) {
  let e = d.createChild("div", parent);
  e.innerHTML = `    ${JSON.stringify(binding)}`;
  e.onmouseleave = () => {
    for (let e of d.allChildren(d.getId("left"))) {
      e.classList.remove("hl");
    }
  };
  e.onmouseenter = () => {
    for (let tuple of used) {
      for (let elem of tupleRefs.get(str(tuple))) {
        elem.classList.add("hl");
      }
    }
  };
  e.onclick = () => {
    if (chosen.has(binding)) chosen.delete(binding);
    else chosen.add(binding);
    checkGlobalChoiceState();
  };
}
function checkGlobalChoiceState() {
  for (let v of globalChoiceState.states.values()) {
    if (!checkChoiceState(v)) return false;
  }
  // ready to go
  globalChoiceState.elements.forEach(d.remove);
  let { db, rules, trace, stack, contexts, operations, name, ruleText } =
    globalChoiceState.entry;
  for (let c of contexts) {
    c.binding._choices = Array.from(globalChoiceState.states.get(c).chosen);
  }
  operations = [{ tag: "applyChoices" }].concat(operations);
  stack.push(mkLine({ contexts, operations, ruleText, name }));
  fixStack(db, rules, trace, stack);
}
function checkChoiceState(state) {
  switch (globalChoiceState.entry.type) {
    case "one":
      return state.chosen.size === 1;
    default:
      throw "missing quantifier type";
  }
}

let parseGuard = (x) => parseQuery(x)[0];
let db = emptyDb();
let initTuples = `
land l1, land l2, land l3,
adjacent l1 l2, adjacent l2 l3, adjacent l3 l2, adjacent l2 l1,
`;
function resetDb() {
  db = dbOfList([
    ["land", [0]],
    ["land", [1]],
    ["land", [2]],
    ["adjacent", [0, 1]],
    ["adjacent", [1, 2]],
    ["adjacent", [2, 1]],
    ["adjacent", [1, 0]],
    //["token", ["t"]],
  ]);
}

function mkRule(name, guard, ruleText) {
  return {
    guard: parseNonterminal("relation", guard),
    body: [parse(ruleText)],
    name,
    ruleText: `(${guard}): ${ruleText}`,
  };
}

console.log("hm", isLiteral(["sym", 0]));
let rule1 = mkRule("moves", "in t l", "after(moved t)");
let oldrule =
  "land x, in t x, choose [exactly 1] (adjacent x y), before (in t x), after (in t y)";
let rules = [
  mkRule("turn1", "init", "after (turn a)"),
  mkRule("make-tokens", "init", "after (token x, token y)"),
  mkRule("init", "init", `after (${initTuples})`),
  mkRule("next-turn", "turn a", "after (turn b)"),
  mkRule(
    "place-token",
    "token t",
    "choose [exactly 1] (land loc), \n after (in t loc)"
  ),
  mkRule(
    "turn-move",
    "turn _",
    "land x, choose [exactly 1] (in t x, adjacent x y), before (in t x), after (in t y)"
  ),
];

function mkTrace() {
  let trace = { entries: [] };
  trace.push = (entry) => {
    renderDb(db);
    renderTraceEntry(entry);
    trace.entries.push(entry);
  };
  return trace;
}

window.onload = () => {
  let contexts = [mkContext({})];
  let line1 = "land x, token t, before (in t x), adjacent x y, after (in t y)";
  let line2 =
    "land x, token t, before (in t x), choose [exactly 1] (adjacent x y), after (in t y)";
  let line2_ =
    "land x, c = count (token t, in t x), one c, choose [exactly 1] (token t, in t x, adjacent x y), before (in t x), after (in t y)";

  //resetDb();
  let trace = mkTrace();
  trace.push({ tag: "record", db: clone(db), name: "init", ruleText: "" });
  function go(ruleText) {
    let operations = parse(ruleText);
    return fixStack(db, rules, trace, [
      mkLine({ name: "repl", ruleText, contexts, operations }),
    ]);
  }
  go(`after(init)`);
};

/* plan

rule stepper
default actions (handle unique choice)
highlight choices
rule editor on screen
  reload rules
  undo to point on trace


**later**
parse diffs
  relate parse of edited rule to previous
  update active choices
    (if rule modified, reset to beginning)

interesting query

custom state viz
  tuple -> element map

binding picker for each quantifier type
  todo soon: up to

*/
